import {
  createStore,
  useStore
} from "./chunk-B3PBNG7G.js";
import {
  require_jsx_runtime
} from "./chunk-U73TBONF.js";
import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/@manapotion/react/dist/index.js
var import_react = __toESM(require_react());

// node_modules/zustand/esm/middleware.mjs
var trackedConnections = /* @__PURE__ */ new Map();
var getTrackedConnectionState = (name) => {
  const api = trackedConnections.get(name);
  if (!api)
    return {};
  return Object.fromEntries(
    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
  );
};
var extractConnectionInformation = (store, extensionConnector, options) => {
  if (store === void 0) {
    return {
      type: "untracked",
      connection: extensionConnector.connect(options)
    };
  }
  const existingConnection = trackedConnections.get(options.name);
  if (existingConnection) {
    return { type: "tracked", store, ...existingConnection };
  }
  const newConnection = {
    connection: extensionConnector.connect(options),
    stores: {}
  };
  trackedConnections.set(options.name, newConnection);
  return { type: "tracked", store, ...newConnection };
};
var devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
  let extensionConnector;
  try {
    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (e) {
  }
  if (!extensionConnector) {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && enabled) {
      console.warn(
        "[zustand devtools middleware] Please install/enable Redux devtools extension"
      );
    }
    return fn(set, get, api);
  }
  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
  let isRecording = true;
  api.setState = (state2, replace, nameOrAction) => {
    const r = set(state2, replace);
    if (!isRecording)
      return r;
    const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
    if (store === void 0) {
      connection == null ? void 0 : connection.send(action, get());
      return r;
    }
    connection == null ? void 0 : connection.send(
      {
        ...action,
        type: `${store}/${action.type}`
      },
      {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      }
    );
    return r;
  };
  const setStateFromDevtools = (...a) => {
    const originalIsRecording = isRecording;
    isRecording = false;
    set(...a);
    isRecording = originalIsRecording;
  };
  const initialState = fn(api.setState, get, api);
  if (connectionInformation.type === "untracked") {
    connection == null ? void 0 : connection.init(initialState);
  } else {
    connectionInformation.stores[connectionInformation.store] = api;
    connection == null ? void 0 : connection.init(
      Object.fromEntries(
        Object.entries(connectionInformation.stores).map(([key, store2]) => [
          key,
          key === connectionInformation.store ? initialState : store2.getState()
        ])
      )
    );
  }
  if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
    let didWarnAboutReservedActionType = false;
    const originalDispatch = api.dispatch;
    api.dispatch = (...a) => {
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && a[0].type === "__setState" && !didWarnAboutReservedActionType) {
        console.warn(
          '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
        );
        didWarnAboutReservedActionType = true;
      }
      originalDispatch(...a);
    };
  }
  connection.subscribe((message) => {
    var _a;
    switch (message.type) {
      case "ACTION":
        if (typeof message.payload !== "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          message.payload,
          (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              if (Object.keys(action.state).length !== 1) {
                console.error(
                  `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                );
              }
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                setStateFromDevtools(stateFromDevtools);
              }
              return;
            }
            if (!api.dispatchFromDevtools)
              return;
            if (typeof api.dispatch !== "function")
              return;
            api.dispatch(action);
          }
        );
      case "DISPATCH":
        switch (message.payload.type) {
          case "RESET":
            setStateFromDevtools(initialState);
            if (store === void 0) {
              return connection == null ? void 0 : connection.init(api.getState());
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "COMMIT":
            if (store === void 0) {
              connection == null ? void 0 : connection.init(api.getState());
              return;
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "ROLLBACK":
            return parseJsonThen(message.state, (state2) => {
              if (store === void 0) {
                setStateFromDevtools(state2);
                connection == null ? void 0 : connection.init(api.getState());
                return;
              }
              setStateFromDevtools(state2[store]);
              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(message.state, (state2) => {
              if (store === void 0) {
                setStateFromDevtools(state2);
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(state2[store])) {
                setStateFromDevtools(state2[store]);
              }
            });
          case "IMPORT_STATE": {
            const { nextLiftedState } = message.payload;
            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
            if (!lastComputedState)
              return;
            if (store === void 0) {
              setStateFromDevtools(lastComputedState);
            } else {
              setStateFromDevtools(lastComputedState[store]);
            }
            connection == null ? void 0 : connection.send(
              null,
              // FIXME no-any
              nextLiftedState
            );
            return;
          }
          case "PAUSE_RECORDING":
            return isRecording = !isRecording;
        }
        return;
    }
  });
  return initialState;
};
var devtools = devtoolsImpl;
var parseJsonThen = (stringified, f) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      e
    );
  }
  if (parsed !== void 0)
    f(parsed);
};

// node_modules/@manapotion/core/dist/index.js
var defaultBrowser = {
  pointerLockSupported: false,
  isFullscreen: false,
  isPageVisible: true,
  isPageFocused: true,
  width: 0,
  height: 0,
  isDesktop: false,
  isMobile: false,
  isPortrait: false,
  isLandscape: false
};
var browserStore = createStore()(
  devtools(() => structuredClone(defaultBrowser), { name: "browser" })
);
var getBrowser = browserStore.getState;
var defaultKeyboard = {
  codes: {},
  keys: {},
  ctrl: false,
  shift: false,
  alt: false,
  meta: false
};
var keyboardStore = createStore()(
  devtools(() => structuredClone(defaultKeyboard), { name: "keyboard" })
);
var getKeyboard = keyboardStore.getState;
var resetKeyboard = () => keyboardStore.setState(() => structuredClone(defaultKeyboard));
var defaultMouse = {
  locked: false,
  position: { x: 0, y: 0 },
  movement: { x: 0, y: 0 },
  wheel: { y: 0 },
  buttons: { left: false, middle: false, right: false }
};
var mouseStore = createStore()(
  devtools(() => structuredClone(defaultMouse), { name: "mouse" })
);
var getMouse = mouseStore.getState;
var resetMouse = () => mouseStore.setState(() => structuredClone(defaultMouse));
var createJoystick = () => ({
  isActive: false,
  identifier: null,
  origin: { x: null, y: null, angle: null, distance: null, distanceRatio: null },
  follow: { x: null, y: null, angle: null, distance: null, distanceRatio: null },
  current: { x: null, y: null },
  movement: { x: 0, y: 0 }
});
var defaultJoysticks = {
  movement: createJoystick(),
  rotation: createJoystick()
};
var joysticksStore = createStore()(
  devtools(() => structuredClone(defaultJoysticks), { name: "joysticks" })
);
var getJoysticks = joysticksStore.getState;
var resetJoysticks = () => joysticksStore.setState(() => structuredClone(defaultJoysticks));
var callbacks = /* @__PURE__ */ new Map();
var callbackLastExecutions = /* @__PURE__ */ new WeakMap();
var state = { delta: 0, elapsed: 0 };
var previousTime = performance.now();
var running = false;
var mainLoop = (time) => {
  if (!running)
    return;
  state.delta = (time - previousTime) / 1e3;
  state.elapsed += state.delta;
  Array.from(callbacks.keys()).sort((a, b) => a - b).forEach((stage) => {
    var _a;
    (_a = callbacks.get(stage)) == null ? void 0 : _a.forEach((callback) => {
      try {
        callback(state);
      } catch (error) {
        console.error("Error in animation frame callback:", error);
      }
    });
  });
  previousTime = time;
  requestAnimationFrame(mainLoop);
};
var addMainLoopEffect = (callback, options) => {
  var _a;
  const throttledCallback = (state2) => {
    const now = performance.now();
    const lastExecution = callbackLastExecutions.get(callback) || 0;
    const throttleInterval = (options == null ? void 0 : options.throttle) || 0;
    if (now - lastExecution >= throttleInterval) {
      callbackLastExecutions.set(callback, now);
      callback(state2);
    }
  };
  const stage = (options == null ? void 0 : options.stage) || 0;
  if (!callbacks.has(stage)) {
    callbacks.set(stage, /* @__PURE__ */ new Set());
  }
  (_a = callbacks.get(stage)) == null ? void 0 : _a.add(throttledCallback);
  if (!running) {
    running = true;
    previousTime = performance.now();
    requestAnimationFrame(mainLoop);
  }
  return () => {
    var _a2, _b;
    (_a2 = callbacks.get(stage)) == null ? void 0 : _a2.delete(throttledCallback);
    if (((_b = callbacks.get(stage)) == null ? void 0 : _b.size) === 0) {
      callbacks.delete(stage);
    }
  };
};
var pauseMainLoop = () => running = false;
var resumeMainLoop = () => {
  if (!running && callbacks.size > 0) {
    running = true;
    previousTime = performance.now();
    requestAnimationFrame(mainLoop);
  }
};
var enterFullscreen = () => {
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  } else if (document.documentElement.mozRequestFullScreen) {
    ;
    document.documentElement.mozRequestFullScreen();
  } else if (document.documentElement.webkitRequestFullscreen) {
    ;
    document.documentElement.webkitRequestFullscreen();
  } else if (document.documentElement.msRequestFullscreen) {
    ;
    document.documentElement.msRequestFullscreen();
  }
};
var exitFullscreen = () => {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.mozCancelFullScreen) {
    ;
    document.mozCancelFullScreen();
  } else if (document.webkitExitFullscreen) {
    ;
    document.webkitExitFullscreen();
  } else if (document.msExitFullscreen) {
    ;
    document.msExitFullscreen();
  }
};
var lockOrientation = (type) => {
  if (screen.orientation.type.startsWith(type)) {
    return;
  }
  if ("lock" in screen.orientation) {
    ;
    screen.orientation.lock(type);
  }
};
var unlockOrientation = () => {
  if ("unlock" in screen.orientation) {
    screen.orientation.unlock();
  }
};
var lockKeys = (keys) => {
  if ("keyboard" in navigator && navigator.keyboard && "lock" in navigator.keyboard && navigator.keyboard.lock) {
    ;
    navigator.keyboard.lock(keys);
  }
};
var unlockKeys = () => {
  if ("keyboard" in navigator && navigator.keyboard && "unlock" in navigator.keyboard && navigator.keyboard.unlock) {
    ;
    navigator.keyboard.unlock();
  }
};
var lockPointer = () => document.body.requestPointerLock();
var unlockPointer = () => document.exitPointerLock();
var xxxxxs = "192px";
var xxxxs = "256px";
var xxxs = "320px";
var xxs = "384px";
var xs = "512px";
var sm = "640px";
var md = "768px";
var lg = "1024px";
var xl = "1280px";
var xxl = "1536px";
var xxxl = "1792px";
var xxxxl = "2048px";
var xxxxxl = "2560px";
var screens = {
  "5xs": xxxxxs,
  "4xs": xxxxs,
  "3xs": xxxs,
  "2xs": xxs,
  xs,
  sm,
  md,
  lg,
  xl,
  "2xl": xxl,
  "3xl": xxxl,
  "4xl": xxxxl,
  "5xl": xxxxxl
};
var extendScreens = {
  // https://github.com/tailwindlabs/tailwindcss/issues/13022
  "max-5xs": { raw: `not all and (min-width: ${xxxxxs})` },
  "max-4xs": { raw: `not all and (min-width: ${xxxxs})` },
  "max-3xs": { raw: `not all and (min-width: ${xxxs})` },
  "max-2xs": { raw: `not all and (min-width: ${xxs})` },
  "max-xs": { raw: `not all and (min-width: ${xs})` },
  "max-sm": { raw: `not all and (min-width: ${sm})` },
  "max-md": { raw: `not all and (min-width: ${md})` },
  "max-lg": { raw: `not all and (min-width: ${lg})` },
  "max-xl": { raw: `not all and (min-width: ${xl})` },
  "max-2xl": { raw: `not all and (min-width: ${xxl})` },
  "max-3xl": { raw: `not all and (min-width: ${xxxl})` },
  "max-4xl": { raw: `not all and (min-width: ${xxxxl})` },
  "max-5xl": { raw: `not all and (min-width: ${xxxxxl})` },
  "5xs-h": { raw: `(min-height: ${xxxxxs})` },
  "4xs-h": { raw: `(min-height: ${xxxxs})` },
  "3xs-h": { raw: `(min-height: ${xxxs})` },
  "2xs-h": { raw: `(min-height: ${xxs})` },
  "xs-h": { raw: `(min-height: ${xs})` },
  "sm-h": { raw: `(min-height: ${sm})` },
  "md-h": { raw: `(min-height: ${md})` },
  "lg-h": { raw: `(min-height: ${lg})` },
  "xl-h": { raw: `(min-height: ${xl})` },
  "2xl-h": { raw: `(min-height: ${xxl})` },
  "3xl-h": { raw: `(min-height: ${xxxl})` },
  "4xl-h": { raw: `(min-height: ${xxxxl})` },
  "5xl-h": { raw: `(min-height: ${xxxxxl})` },
  "max-5xs-h": { raw: `not all and (min-height: ${xxxxxs})` },
  "max-4xs-h": { raw: `not all and (min-height: ${xxxxs})` },
  "max-3xs-h": { raw: `not all and (min-height: ${xxxs})` },
  "max-2xs-h": { raw: `not all and (min-height: ${xxs})` },
  "max-xs-h": { raw: `not all and (min-height: ${xs})` },
  "max-sm-h": { raw: `not all and (min-height: ${sm})` },
  "max-md-h": { raw: `not all and (min-height: ${md})` },
  "max-lg-h": { raw: `not all and (min-height: ${lg})` },
  "max-xl-h": { raw: `not all and (min-height: ${xl})` },
  "max-2xl-h": { raw: `not all and (min-height: ${xxl})` },
  "max-3xl-h": { raw: `not all and (min-height: ${xxxl})` },
  "max-4xl-h": { raw: `not all and (min-height: ${xxxxl})` },
  "max-5xl-h": { raw: `not all and (min-height: ${xxxxxl})` },
  mobile: { raw: "(hover: none) and (pointer: coarse)" },
  desktop: { raw: "(hover: hover) and (pointer: fine)" }
};
var tailwindTheme = { screens, extend: { screens: extendScreens } };
var { sin, cos, sqrt, pow, atan2 } = Math;
var pi = Math.PI;
var mountJoystickArea = ({
  joystick,
  mode = "follow",
  maxFollowDistance = 50,
  maxOriginDistance = 50,
  element,
  onStart,
  onEnd,
  onMove
}) => {
  if (!joystick) {
    console.error("JoystickArea: an joystick object is required");
  }
  let resetMovementTimeout = null;
  let endResetTimeout = null;
  const resetJoystick = () => {
    if (!joystick) {
      return;
    }
    joystick.identifier = null;
    joystick.isActive = false;
    joystick.origin.x = null;
    joystick.origin.y = null;
    joystick.origin.angle = null;
    joystick.origin.distance = null;
    joystick.origin.distanceRatio = null;
    joystick.follow.x = null;
    joystick.follow.y = null;
    joystick.follow.angle = null;
    joystick.follow.distance = null;
    joystick.follow.distanceRatio = null;
    joystick.current.x = null;
    joystick.current.y = null;
    joystick.movement.x = 0;
    joystick.movement.y = 0;
  };
  const handleTouchStart = (e) => {
    e.preventDefault();
    const touch = e.changedTouches.item(0);
    if (!touch || !joystick || joystick.identifier != void 0) {
      return;
    }
    const target = e.target;
    const rect = target.getBoundingClientRect();
    const currentX = touch.clientX - rect.left;
    const currentY = rect.height - (touch.clientY - rect.top);
    joystick.identifier = touch.identifier;
    joystick.isActive = true;
    joystick.origin.x = currentX;
    joystick.origin.y = currentY;
    joystick.origin.angle = 0;
    joystick.origin.distance = 0;
    joystick.origin.distanceRatio = 0;
    if (mode === "follow") {
      joystick.follow.x = currentX;
      joystick.follow.y = currentY;
      joystick.follow.angle = 0;
      joystick.follow.distance = 0;
      joystick.follow.distanceRatio = 0;
    }
    joystick.current.x = currentX;
    joystick.current.y = currentY;
    joystick.movement.x = 0;
    joystick.movement.y = 0;
    onStart == null ? void 0 : onStart(joystick);
  };
  const handleTouchMove = (e) => {
    e.preventDefault();
    if (!joystick) {
      return;
    }
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches.item(i);
      if (!touch || joystick.identifier !== touch.identifier) {
        continue;
      }
      if (joystick.origin.x === null || joystick.origin.y === null || joystick.current.x === null || joystick.current.y === null) {
        continue;
      }
      const target = e.target;
      const rect = target.getBoundingClientRect();
      const fingerPositionX = touch.clientX - rect.left;
      const fingerPositionY = rect.height - (touch.clientY - rect.top);
      const fingerOriginDistance = sqrt(
        pow(fingerPositionX - joystick.origin.x, 2) + pow(fingerPositionY - joystick.origin.y, 2)
      );
      joystick.origin.angle = (atan2(fingerPositionY - joystick.origin.y, fingerPositionX - joystick.origin.x) + 2 * pi) % (2 * pi);
      const currentX = mode === "origin" ? joystick.origin.x + Math.min(fingerOriginDistance, maxOriginDistance) * cos(joystick.origin.angle) : touch.clientX - rect.left;
      const currentY = mode === "origin" ? joystick.origin.y + Math.min(fingerOriginDistance, maxOriginDistance) * sin(joystick.origin.angle) : rect.height - (touch.clientY - rect.top);
      joystick.movement.x = currentX - joystick.current.x;
      joystick.movement.y = currentY - joystick.current.y;
      joystick.current.x = currentX;
      joystick.current.y = currentY;
      joystick.origin.distance = sqrt(
        pow(currentX - joystick.origin.x, 2) + pow(currentY - joystick.origin.y, 2)
      );
      if (mode === "origin") {
        if (joystick.origin.distance > maxOriginDistance - 0.01) {
          joystick.origin.distance = maxOriginDistance;
        }
      }
      joystick.origin.distanceRatio = maxOriginDistance ? joystick.origin.distance / maxOriginDistance : 1;
      if (joystick.origin.distanceRatio > 0.99) {
        joystick.origin.distanceRatio = 1;
      }
      if (mode === "follow") {
        if (joystick.follow.x !== null && joystick.follow.y !== null) {
          joystick.follow.angle = (atan2(fingerPositionY - joystick.follow.y, fingerPositionX - joystick.follow.x) + 2 * pi) % (2 * pi);
          joystick.follow.distance = sqrt(
            pow(currentX - joystick.follow.x, 2) + pow(currentY - joystick.follow.y, 2)
          );
          if (joystick.follow.distance > maxFollowDistance - 0.01) {
            joystick.follow.distance = maxFollowDistance;
          }
          joystick.follow.distanceRatio = maxFollowDistance ? joystick.follow.distance / maxFollowDistance : 1;
          joystick.follow.angle = (atan2(currentY - joystick.follow.y, currentX - joystick.follow.x) + 2 * pi) % (2 * pi);
          if (joystick.follow.distance >= maxFollowDistance) {
            const oppositeFollowAngle = Math.atan2(
              joystick.follow.y - currentY,
              joystick.follow.x - currentX
            );
            joystick.follow.x = currentX + maxFollowDistance * cos(oppositeFollowAngle);
            joystick.follow.y = currentY + maxFollowDistance * sin(oppositeFollowAngle);
          }
        }
      }
      joystick.origin.angle = (atan2(currentY - joystick.origin.y, currentX - joystick.origin.x) + 2 * pi) % (2 * pi);
      onMove == null ? void 0 : onMove(joystick);
      resetMovementTimeout && clearTimeout(resetMovementTimeout);
      resetMovementTimeout = setTimeout(() => {
        if (joystick && joystick.identifier !== void 0) {
          joystick.movement.x = 0;
          joystick.movement.y = 0;
          onMove == null ? void 0 : onMove(joystick);
        }
      }, 70);
    }
  };
  const handleTouchEnd = (e) => {
    e.preventDefault();
    if (!joystick) {
      return;
    }
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches.item(i);
      if (!touch || joystick.identifier !== touch.identifier) {
        continue;
      }
      joystick.movement.x = 0;
      joystick.movement.y = 0;
      onEnd == null ? void 0 : onEnd(joystick);
      endResetTimeout = setTimeout(() => {
        resetJoystick();
        onEnd == null ? void 0 : onEnd(joystick);
      }, 50);
    }
  };
  element.addEventListener(
    "touchstart",
    handleTouchStart
    /*, { passive: false } */
  );
  element.addEventListener(
    "touchmove",
    handleTouchMove
    /*, { passive: false } */
  );
  element.addEventListener(
    "touchend",
    handleTouchEnd
    /*, { passive: false } */
  );
  return () => {
    resetMovementTimeout && clearTimeout(resetMovementTimeout);
    endResetTimeout && clearTimeout(endResetTimeout);
    element.removeEventListener("touchstart", handleTouchStart);
    element.removeEventListener("touchmove", handleTouchMove);
    element.removeEventListener("touchend", handleTouchEnd);
  };
};
var mountDeviceTypeListener = ({ onDeviceTypeChange }) => {
  const desktopQuery = window.matchMedia("(hover: hover) and (pointer: fine)");
  const mobileQuery = window.matchMedia("(hover: none) and (pointer: coarse)");
  const handler = () => {
    const isDesktop = desktopQuery.matches;
    const isMobile = mobileQuery.matches;
    browserStore.setState((s) => ({ ...s, isDesktop, isMobile }));
    onDeviceTypeChange == null ? void 0 : onDeviceTypeChange({ isDesktop, isMobile });
  };
  handler();
  desktopQuery.addEventListener("change", handler);
  return () => desktopQuery.removeEventListener("change", handler);
};
var mountFullscreenListener = ({ onFullscreenChange }) => {
  const handler = () => {
    const isFullscreen = Boolean(document.fullscreenElement);
    browserStore.setState((s) => ({ ...s, isFullscreen }));
    onFullscreenChange == null ? void 0 : onFullscreenChange({ isFullscreen });
  };
  handler();
  document.addEventListener("fullscreenchange", handler);
  return () => document.removeEventListener("fullscreenchange", handler);
};
var mountKeyboardListener = ({ onKeyUp, onKeyDown }) => {
  const downHandler = (e) => {
    const { key, code } = e;
    const keyboard = getKeyboard();
    if (keyboard.codes[code] || keyboard.keys[key]) {
      return;
    }
    keyboardStore.setState((s) => ({
      ...s,
      codes: { ...s.codes, [code]: true },
      keys: { ...s.keys, [key]: true },
      ctrl: e.ctrlKey,
      shift: e.shiftKey,
      alt: e.altKey,
      meta: e.metaKey
    }));
    onKeyDown == null ? void 0 : onKeyDown({
      code,
      key,
      ctrl: e.ctrlKey,
      shift: e.shiftKey,
      alt: e.altKey,
      meta: e.metaKey
    });
  };
  const upHandler = (e) => {
    keyboardStore.setState((s) => {
      const newKeyboard = { ...s, codes: { ...s.codes }, keys: { ...s.keys } };
      delete newKeyboard.codes[e.code];
      delete newKeyboard.keys[e.key];
      delete newKeyboard.keys[e.key.toUpperCase()];
      delete newKeyboard.keys[e.key.toLowerCase()];
      delete newKeyboard.keys.Dead;
      newKeyboard.ctrl = e.ctrlKey;
      newKeyboard.shift = e.shiftKey;
      newKeyboard.alt = e.altKey;
      newKeyboard.meta = e.metaKey;
      return newKeyboard;
    });
    onKeyUp == null ? void 0 : onKeyUp({
      code: e.code,
      key: e.key,
      ctrl: e.ctrlKey,
      shift: e.shiftKey,
      alt: e.altKey,
      meta: e.metaKey
    });
  };
  window.addEventListener("keydown", downHandler);
  window.addEventListener("keyup", upHandler);
  return () => {
    window.removeEventListener("keydown", downHandler);
    window.removeEventListener("keyup", upHandler);
  };
};
var mountMouseButtonsListener = ({
  onLeftMouseButtonDown,
  onMiddleMouseButtonDown,
  onRightMouseButtonDown,
  onLeftMouseButtonUp,
  onMiddleMouseButtonUp,
  onRightMouseButtonUp
}) => {
  const emptyObject = {};
  const downHandler = (e) => {
    const left = (e.buttons & 1) !== 0;
    const middle = (e.buttons & 4) !== 0;
    const right = (e.buttons & 2) !== 0;
    mouseStore.setState((s) => {
      const newMouse = structuredClone(s);
      const buttons = newMouse.buttons;
      buttons.left = left;
      buttons.middle = middle;
      buttons.right = right;
      return newMouse;
    });
    if (e.button === 0) {
      onLeftMouseButtonDown == null ? void 0 : onLeftMouseButtonDown(emptyObject);
    } else if (e.button === 1) {
      onMiddleMouseButtonDown == null ? void 0 : onMiddleMouseButtonDown(emptyObject);
    } else if (e.button === 2) {
      onRightMouseButtonDown == null ? void 0 : onRightMouseButtonDown(emptyObject);
    }
  };
  const upHandler = (e) => {
    const left = (e.buttons & 1) !== 0;
    const middle = (e.buttons & 4) !== 0;
    const right = (e.buttons & 2) !== 0;
    mouseStore.setState((s) => {
      const newMouse = structuredClone(s);
      const buttons = newMouse.buttons;
      buttons.left = left;
      buttons.middle = middle;
      buttons.right = right;
      return newMouse;
    });
    if (e.button === 0) {
      onLeftMouseButtonUp == null ? void 0 : onLeftMouseButtonUp(emptyObject);
    } else if (e.button === 1) {
      onMiddleMouseButtonUp == null ? void 0 : onMiddleMouseButtonUp(emptyObject);
    } else if (e.button === 2) {
      onRightMouseButtonUp == null ? void 0 : onRightMouseButtonUp(emptyObject);
    }
  };
  window.addEventListener("mousedown", downHandler);
  window.addEventListener("mouseup", upHandler);
  return () => {
    window.removeEventListener("mousedown", downHandler);
    window.removeEventListener("mouseup", upHandler);
  };
};
var movementResetTimeout = null;
var mountMouseMoveListener = ({
  onMouseMove,
  mouseMovementResetDelay = 30
}) => {
  const payload = { position: { x: 0, y: 0 }, movement: { x: 0, y: 0 } };
  const handler = (e) => {
    const mouse = getMouse();
    const position = mouse.position;
    const movement = mouse.movement;
    position.x = e.clientX;
    position.y = window.innerHeight - e.clientY;
    movement.x = e.movementX;
    movement.y = -e.movementY;
    payload.position.x = position.x;
    payload.position.y = position.y;
    payload.movement.x = movement.x;
    payload.movement.y = movement.y;
    onMouseMove == null ? void 0 : onMouseMove(payload);
    movementResetTimeout && clearTimeout(movementResetTimeout);
    if (mouseMovementResetDelay) {
      movementResetTimeout = setTimeout(() => {
        movement.x = 0;
        movement.y = 0;
        payload.movement.x = movement.x;
        payload.movement.y = movement.y;
        onMouseMove == null ? void 0 : onMouseMove(payload);
      }, mouseMovementResetDelay);
    }
  };
  window.addEventListener("mousemove", handler);
  return () => {
    movementResetTimeout && clearTimeout(movementResetTimeout);
    window.removeEventListener("mousemove", handler);
  };
};
var resetTimeout = null;
var mountMouseScrollListener = ({
  onScroll,
  mouseScrollResetDelay = 100
}) => {
  const payload = { y: 0 };
  const handler = (e) => {
    const mouse = getMouse();
    const wheel = mouse.wheel;
    wheel.y = e.deltaY;
    payload.y = wheel.y;
    onScroll == null ? void 0 : onScroll(payload);
    resetTimeout && clearTimeout(resetTimeout);
    if (mouseScrollResetDelay) {
      resetTimeout = setTimeout(() => {
        wheel.y = 0;
        payload.y = wheel.y;
        onScroll == null ? void 0 : onScroll(payload);
      }, mouseScrollResetDelay);
    }
  };
  window.addEventListener("wheel", handler);
  return () => {
    resetTimeout && clearTimeout(resetTimeout);
    window.removeEventListener("wheel", handler);
  };
};
var mountPageFocusListener = ({ onPageFocusChange }) => {
  const handler = () => {
    const isPageFocused = document.hasFocus();
    browserStore.setState((s) => ({ ...s, isPageFocused }));
    onPageFocusChange == null ? void 0 : onPageFocusChange({ isPageFocused });
  };
  handler();
  window.addEventListener("focus", handler);
  window.addEventListener("blur", handler);
  return () => {
    window.removeEventListener("focus", handler);
    window.removeEventListener("blur", handler);
  };
};
var mountPageVisibilityListener = ({
  onPageVisibilityChange
}) => {
  const handler = () => {
    const isPageVisible = !document.hidden;
    browserStore.setState((s) => ({ ...s, isPageVisible }));
    onPageVisibilityChange == null ? void 0 : onPageVisibilityChange({ isPageVisible });
  };
  handler();
  document.addEventListener("visibilitychange", handler);
  return () => document.removeEventListener("visibilitychange", handler);
};
var mountPointerLockListener = ({ onPointerLockChange }) => {
  const handler = () => {
    const locked = Boolean(document.pointerLockElement);
    mouseStore.setState((s) => {
      const newMouse = structuredClone(s);
      newMouse.locked = locked;
      return newMouse;
    });
    onPointerLockChange == null ? void 0 : onPointerLockChange({ isPointerLocked: locked });
  };
  handler();
  document.addEventListener("pointerlockchange", handler);
  return () => document.removeEventListener("pointerlockchange", handler);
};
var mountResizeListener = ({ onResize }) => {
  const payload = { width: 0, height: 0 };
  const handler = () => {
    const browser = getBrowser();
    const width = window.innerWidth;
    const height = window.innerHeight;
    browser.width = width;
    browser.height = height;
    payload.width = browser.width;
    payload.height = browser.height;
    onResize == null ? void 0 : onResize(payload);
  };
  handler();
  window.addEventListener("resize", handler);
  return () => window.removeEventListener("resize", handler);
};
var mountScreenOrientationListener = ({
  onScreenOrientationChange
}) => {
  const landscapeQuery = window.matchMedia("(orientation: landscape)");
  const portraitQuery = window.matchMedia("(orientation: portrait)");
  const handler = () => {
    const isLandscape = landscapeQuery.matches;
    const isPortrait = portraitQuery.matches;
    browserStore.setState((s) => ({ ...s, isLandscape, isPortrait }));
    onScreenOrientationChange == null ? void 0 : onScreenOrientationChange({ isLandscape, isPortrait });
  };
  handler();
  landscapeQuery.addEventListener("change", handler);
  return () => landscapeQuery.removeEventListener("change", handler);
};

// node_modules/@manapotion/react/dist/index.js
var import_react2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var import_react5 = __toESM(require_react());
var import_react6 = __toESM(require_react());
var import_react7 = __toESM(require_react());
var import_react8 = __toESM(require_react());
var import_react9 = __toESM(require_react());
var import_react10 = __toESM(require_react());
var import_react11 = __toESM(require_react());
var import_react12 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react13 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var useMainLoop = (callback, options) => {
  (0, import_react.useEffect)(() => addMainLoopEffect(callback, options), []);
};
var DeviceTypeListener = ({ onDeviceTypeChange }) => {
  (0, import_react2.useEffect)(() => mountDeviceTypeListener({ onDeviceTypeChange }), []);
  return null;
};
var FullscreenListener = ({ onFullscreenChange }) => {
  (0, import_react3.useEffect)(() => mountFullscreenListener({ onFullscreenChange }), []);
  return null;
};
var KeyboardListener = ({ onKeyDown, onKeyUp }) => {
  (0, import_react4.useEffect)(() => mountKeyboardListener({ onKeyDown, onKeyUp }), []);
  return null;
};
var MouseButtonsListener = ({
  onLeftMouseButtonDown,
  onMiddleMouseButtonDown,
  onRightMouseButtonDown,
  onLeftMouseButtonUp,
  onMiddleMouseButtonUp,
  onRightMouseButtonUp
}) => {
  (0, import_react5.useEffect)(
    () => mountMouseButtonsListener({
      onLeftMouseButtonDown,
      onMiddleMouseButtonDown,
      onRightMouseButtonDown,
      onLeftMouseButtonUp,
      onMiddleMouseButtonUp,
      onRightMouseButtonUp
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  return null;
};
var MouseMoveListener = ({
  mouseMovementResetDelay,
  onMouseMove
}) => {
  (0, import_react6.useEffect)(
    () => mountMouseMoveListener({ onMouseMove, mouseMovementResetDelay }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [mouseMovementResetDelay]
  );
  return null;
};
var MouseScrollListener = ({
  onScroll,
  mouseScrollResetDelay
}) => {
  (0, import_react7.useEffect)(
    () => mountMouseScrollListener({ onScroll, mouseScrollResetDelay }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [mouseScrollResetDelay]
  );
  return null;
};
var PageFocusListener = ({ onPageFocusChange }) => {
  (0, import_react8.useEffect)(() => mountPageFocusListener({ onPageFocusChange }), []);
  return null;
};
var PageVisibilityListener = ({ onPageVisibilityChange }) => {
  (0, import_react9.useEffect)(() => mountPageVisibilityListener({ onPageVisibilityChange }), []);
  return null;
};
var PointerLockListener = ({ onPointerLockChange }) => {
  (0, import_react10.useEffect)(() => mountPointerLockListener({ onPointerLockChange }), []);
  return null;
};
var ResizeListener = ({ onResize }) => {
  (0, import_react11.useEffect)(() => mountResizeListener({ onResize }), []);
  return null;
};
var ScreenOrientationListener = ({
  onScreenOrientationChange
}) => {
  (0, import_react12.useEffect)(() => mountScreenOrientationListener({ onScreenOrientationChange }), []);
  return null;
};
var Listeners = ({
  mouseMovementResetDelay,
  onMouseMove,
  onPageVisibilityChange,
  onPageFocusChange,
  onPointerLockChange,
  onFullscreenChange,
  onResize,
  onDeviceTypeChange,
  onScreenOrientationChange,
  onLeftMouseButtonDown,
  onMiddleMouseButtonDown,
  onRightMouseButtonDown,
  onLeftMouseButtonUp,
  onMiddleMouseButtonUp,
  onRightMouseButtonUp,
  onScroll,
  mouseScrollResetDelay,
  onKeyDown,
  onKeyUp
}) => (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
  (0, import_jsx_runtime.jsx)(
    MouseMoveListener,
    {
      mouseMovementResetDelay,
      onMouseMove
    }
  ),
  (0, import_jsx_runtime.jsx)(PageVisibilityListener, { onPageVisibilityChange }),
  (0, import_jsx_runtime.jsx)(PageFocusListener, { onPageFocusChange }),
  (0, import_jsx_runtime.jsx)(PointerLockListener, { onPointerLockChange }),
  (0, import_jsx_runtime.jsx)(FullscreenListener, { onFullscreenChange }),
  (0, import_jsx_runtime.jsx)(ResizeListener, { onResize }),
  (0, import_jsx_runtime.jsx)(DeviceTypeListener, { onDeviceTypeChange }),
  (0, import_jsx_runtime.jsx)(ScreenOrientationListener, { onScreenOrientationChange }),
  (0, import_jsx_runtime.jsx)(
    MouseButtonsListener,
    {
      onLeftMouseButtonDown,
      onMiddleMouseButtonDown,
      onRightMouseButtonDown,
      onLeftMouseButtonUp,
      onMiddleMouseButtonUp,
      onRightMouseButtonUp
    }
  ),
  (0, import_jsx_runtime.jsx)(KeyboardListener, { onKeyDown, onKeyUp }),
  (0, import_jsx_runtime.jsx)(MouseScrollListener, { onScroll, mouseScrollResetDelay })
] });
function useBrowser(selector) {
  return useStore(browserStore, selector);
}
function useMouse(selector) {
  return useStore(mouseStore, selector);
}
function useKeyboard(selector) {
  return useStore(keyboardStore, selector);
}
function useJoysticks(selector) {
  return useStore(joysticksStore, selector);
}
function mergeRefs(refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ;
        ref.current = value;
      }
    });
  };
}
var JoystickAreaBase = ({
  mode,
  joystick,
  maxFollowDistance,
  maxOriginDistance,
  onEnd,
  onMove,
  onStart,
  containerProps,
  children
}, ref) => {
  const localRef = (0, import_react13.useRef)(null);
  const mergedRefs = mergeRefs([localRef, ref]);
  (0, import_react13.useEffect)(
    () => mountJoystickArea({
      mode,
      joystick,
      maxFollowDistance,
      maxOriginDistance,
      onEnd,
      onMove,
      onStart,
      element: localRef.current
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [mode, joystick, maxFollowDistance, maxOriginDistance]
  );
  return (0, import_jsx_runtime2.jsx)("div", { ref: mergedRefs, ...containerProps, children });
};
var JoystickArea = (0, import_react13.forwardRef)(JoystickAreaBase);
JoystickArea.displayName = "JoystickArea";
export {
  DeviceTypeListener,
  FullscreenListener,
  JoystickArea,
  KeyboardListener,
  Listeners,
  MouseButtonsListener,
  MouseMoveListener,
  MouseScrollListener,
  PageFocusListener,
  PageVisibilityListener,
  PointerLockListener,
  ResizeListener,
  ScreenOrientationListener,
  addMainLoopEffect,
  browserStore,
  createJoystick,
  enterFullscreen,
  exitFullscreen,
  getBrowser,
  getJoysticks,
  getKeyboard,
  getMouse,
  joysticksStore,
  keyboardStore,
  lockKeys,
  lockOrientation,
  lockPointer,
  mountDeviceTypeListener,
  mountFullscreenListener,
  mountJoystickArea,
  mountKeyboardListener,
  mountMouseButtonsListener,
  mountMouseMoveListener,
  mountMouseScrollListener,
  mountPageFocusListener,
  mountPageVisibilityListener,
  mountPointerLockListener,
  mountResizeListener,
  mountScreenOrientationListener,
  mouseStore,
  pauseMainLoop,
  resetJoysticks,
  resetKeyboard,
  resetMouse,
  resumeMainLoop,
  tailwindTheme,
  unlockKeys,
  unlockOrientation,
  unlockPointer,
  useBrowser,
  useJoysticks,
  useKeyboard,
  useMainLoop,
  useMouse
};
//# sourceMappingURL=@manapotion_react.js.map
