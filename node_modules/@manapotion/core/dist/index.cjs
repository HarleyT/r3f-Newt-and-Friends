"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  addMainLoopEffect: () => addMainLoopEffect,
  browserStore: () => browserStore,
  createJoystick: () => createJoystick,
  enterFullscreen: () => enterFullscreen,
  exitFullscreen: () => exitFullscreen,
  getBrowser: () => getBrowser,
  getJoysticks: () => getJoysticks,
  getKeyboard: () => getKeyboard,
  getMouse: () => getMouse,
  joysticksStore: () => joysticksStore,
  keyboardStore: () => keyboardStore,
  lockKeys: () => lockKeys,
  lockOrientation: () => lockOrientation,
  lockPointer: () => lockPointer,
  mountDeviceTypeListener: () => mountDeviceTypeListener,
  mountFullscreenListener: () => mountFullscreenListener,
  mountJoystickArea: () => mountJoystickArea,
  mountKeyboardListener: () => mountKeyboardListener,
  mountMouseButtonsListener: () => mountMouseButtonsListener,
  mountMouseMoveListener: () => mountMouseMoveListener,
  mountMouseScrollListener: () => mountMouseScrollListener,
  mountPageFocusListener: () => mountPageFocusListener,
  mountPageVisibilityListener: () => mountPageVisibilityListener,
  mountPointerLockListener: () => mountPointerLockListener,
  mountResizeListener: () => mountResizeListener,
  mountScreenOrientationListener: () => mountScreenOrientationListener,
  mouseStore: () => mouseStore,
  pauseMainLoop: () => pauseMainLoop,
  resetJoysticks: () => resetJoysticks,
  resetKeyboard: () => resetKeyboard,
  resetMouse: () => resetMouse,
  resumeMainLoop: () => resumeMainLoop,
  tailwindTheme: () => tailwindTheme,
  unlockKeys: () => unlockKeys,
  unlockOrientation: () => unlockOrientation,
  unlockPointer: () => unlockPointer
});
module.exports = __toCommonJS(src_exports);

// src/stores/browserStore.ts
var import_middleware = require("zustand/middleware");
var import_vanilla = require("zustand/vanilla");
var defaultBrowser = {
  pointerLockSupported: false,
  isFullscreen: false,
  isPageVisible: true,
  isPageFocused: true,
  width: 0,
  height: 0,
  isDesktop: false,
  isMobile: false,
  isPortrait: false,
  isLandscape: false
};
var browserStore = (0, import_vanilla.createStore)()(
  (0, import_middleware.devtools)(() => structuredClone(defaultBrowser), { name: "browser" })
);
var getBrowser = browserStore.getState;

// src/stores/keyboardStore.ts
var import_middleware2 = require("zustand/middleware");
var import_vanilla2 = require("zustand/vanilla");
var defaultKeyboard = {
  codes: {},
  keys: {},
  ctrl: false,
  shift: false,
  alt: false,
  meta: false
};
var keyboardStore = (0, import_vanilla2.createStore)()(
  (0, import_middleware2.devtools)(() => structuredClone(defaultKeyboard), { name: "keyboard" })
);
var getKeyboard = keyboardStore.getState;
var resetKeyboard = () => keyboardStore.setState(() => structuredClone(defaultKeyboard));

// src/stores/mouseStore.ts
var import_middleware3 = require("zustand/middleware");
var import_vanilla3 = require("zustand/vanilla");
var defaultMouse = {
  locked: false,
  position: { x: 0, y: 0 },
  movement: { x: 0, y: 0 },
  wheel: { y: 0 },
  buttons: { left: false, middle: false, right: false }
};
var mouseStore = (0, import_vanilla3.createStore)()(
  (0, import_middleware3.devtools)(() => structuredClone(defaultMouse), { name: "mouse" })
);
var getMouse = mouseStore.getState;
var resetMouse = () => mouseStore.setState(() => structuredClone(defaultMouse));

// src/stores/joysticksStore.ts
var import_middleware4 = require("zustand/middleware");
var import_vanilla4 = require("zustand/vanilla");
var createJoystick = () => ({
  isActive: false,
  identifier: null,
  origin: { x: null, y: null, angle: null, distance: null, distanceRatio: null },
  follow: { x: null, y: null, angle: null, distance: null, distanceRatio: null },
  current: { x: null, y: null },
  movement: { x: 0, y: 0 }
});
var defaultJoysticks = {
  movement: createJoystick(),
  rotation: createJoystick()
};
var joysticksStore = (0, import_vanilla4.createStore)()(
  (0, import_middleware4.devtools)(() => structuredClone(defaultJoysticks), { name: "joysticks" })
);
var getJoysticks = joysticksStore.getState;
var resetJoysticks = () => joysticksStore.setState(() => structuredClone(defaultJoysticks));

// src/main-loop.ts
var callbacks = /* @__PURE__ */ new Map();
var callbackLastExecutions = /* @__PURE__ */ new WeakMap();
var state = { delta: 0, elapsed: 0 };
var previousTime = performance.now();
var running = false;
var mainLoop = (time) => {
  if (!running)
    return;
  state.delta = (time - previousTime) / 1e3;
  state.elapsed += state.delta;
  Array.from(callbacks.keys()).sort((a, b) => a - b).forEach((stage) => {
    callbacks.get(stage)?.forEach((callback) => {
      try {
        callback(state);
      } catch (error) {
        console.error("Error in animation frame callback:", error);
      }
    });
  });
  previousTime = time;
  requestAnimationFrame(mainLoop);
};
var addMainLoopEffect = (callback, options) => {
  const throttledCallback = (state2) => {
    const now = performance.now();
    const lastExecution = callbackLastExecutions.get(callback) || 0;
    const throttleInterval = options?.throttle || 0;
    if (now - lastExecution >= throttleInterval) {
      callbackLastExecutions.set(callback, now);
      callback(state2);
    }
  };
  const stage = options?.stage || 0;
  if (!callbacks.has(stage)) {
    callbacks.set(stage, /* @__PURE__ */ new Set());
  }
  callbacks.get(stage)?.add(throttledCallback);
  if (!running) {
    running = true;
    previousTime = performance.now();
    requestAnimationFrame(mainLoop);
  }
  return () => {
    callbacks.get(stage)?.delete(throttledCallback);
    if (callbacks.get(stage)?.size === 0) {
      callbacks.delete(stage);
    }
  };
};
var pauseMainLoop = () => running = false;
var resumeMainLoop = () => {
  if (!running && callbacks.size > 0) {
    running = true;
    previousTime = performance.now();
    requestAnimationFrame(mainLoop);
  }
};

// src/browser.ts
var enterFullscreen = () => {
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  } else if (document.documentElement.mozRequestFullScreen) {
    ;
    document.documentElement.mozRequestFullScreen();
  } else if (document.documentElement.webkitRequestFullscreen) {
    ;
    document.documentElement.webkitRequestFullscreen();
  } else if (document.documentElement.msRequestFullscreen) {
    ;
    document.documentElement.msRequestFullscreen();
  }
};
var exitFullscreen = () => {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.mozCancelFullScreen) {
    ;
    document.mozCancelFullScreen();
  } else if (document.webkitExitFullscreen) {
    ;
    document.webkitExitFullscreen();
  } else if (document.msExitFullscreen) {
    ;
    document.msExitFullscreen();
  }
};
var lockOrientation = (type) => {
  if (screen.orientation.type.startsWith(type)) {
    return;
  }
  if ("lock" in screen.orientation) {
    ;
    screen.orientation.lock(type);
  }
};
var unlockOrientation = () => {
  if ("unlock" in screen.orientation) {
    screen.orientation.unlock();
  }
};
var lockKeys = (keys) => {
  if ("keyboard" in navigator && navigator.keyboard && "lock" in navigator.keyboard && navigator.keyboard.lock) {
    ;
    navigator.keyboard.lock(keys);
  }
};
var unlockKeys = () => {
  if ("keyboard" in navigator && navigator.keyboard && "unlock" in navigator.keyboard && navigator.keyboard.unlock) {
    ;
    navigator.keyboard.unlock();
  }
};
var lockPointer = () => document.body.requestPointerLock();
var unlockPointer = () => document.exitPointerLock();

// src/tailwind.ts
var xxxxxs = "192px";
var xxxxs = "256px";
var xxxs = "320px";
var xxs = "384px";
var xs = "512px";
var sm = "640px";
var md = "768px";
var lg = "1024px";
var xl = "1280px";
var xxl = "1536px";
var xxxl = "1792px";
var xxxxl = "2048px";
var xxxxxl = "2560px";
var screens = {
  "5xs": xxxxxs,
  "4xs": xxxxs,
  "3xs": xxxs,
  "2xs": xxs,
  xs,
  sm,
  md,
  lg,
  xl,
  "2xl": xxl,
  "3xl": xxxl,
  "4xl": xxxxl,
  "5xl": xxxxxl
};
var extendScreens = {
  // https://github.com/tailwindlabs/tailwindcss/issues/13022
  "max-5xs": { raw: `not all and (min-width: ${xxxxxs})` },
  "max-4xs": { raw: `not all and (min-width: ${xxxxs})` },
  "max-3xs": { raw: `not all and (min-width: ${xxxs})` },
  "max-2xs": { raw: `not all and (min-width: ${xxs})` },
  "max-xs": { raw: `not all and (min-width: ${xs})` },
  "max-sm": { raw: `not all and (min-width: ${sm})` },
  "max-md": { raw: `not all and (min-width: ${md})` },
  "max-lg": { raw: `not all and (min-width: ${lg})` },
  "max-xl": { raw: `not all and (min-width: ${xl})` },
  "max-2xl": { raw: `not all and (min-width: ${xxl})` },
  "max-3xl": { raw: `not all and (min-width: ${xxxl})` },
  "max-4xl": { raw: `not all and (min-width: ${xxxxl})` },
  "max-5xl": { raw: `not all and (min-width: ${xxxxxl})` },
  "5xs-h": { raw: `(min-height: ${xxxxxs})` },
  "4xs-h": { raw: `(min-height: ${xxxxs})` },
  "3xs-h": { raw: `(min-height: ${xxxs})` },
  "2xs-h": { raw: `(min-height: ${xxs})` },
  "xs-h": { raw: `(min-height: ${xs})` },
  "sm-h": { raw: `(min-height: ${sm})` },
  "md-h": { raw: `(min-height: ${md})` },
  "lg-h": { raw: `(min-height: ${lg})` },
  "xl-h": { raw: `(min-height: ${xl})` },
  "2xl-h": { raw: `(min-height: ${xxl})` },
  "3xl-h": { raw: `(min-height: ${xxxl})` },
  "4xl-h": { raw: `(min-height: ${xxxxl})` },
  "5xl-h": { raw: `(min-height: ${xxxxxl})` },
  "max-5xs-h": { raw: `not all and (min-height: ${xxxxxs})` },
  "max-4xs-h": { raw: `not all and (min-height: ${xxxxs})` },
  "max-3xs-h": { raw: `not all and (min-height: ${xxxs})` },
  "max-2xs-h": { raw: `not all and (min-height: ${xxs})` },
  "max-xs-h": { raw: `not all and (min-height: ${xs})` },
  "max-sm-h": { raw: `not all and (min-height: ${sm})` },
  "max-md-h": { raw: `not all and (min-height: ${md})` },
  "max-lg-h": { raw: `not all and (min-height: ${lg})` },
  "max-xl-h": { raw: `not all and (min-height: ${xl})` },
  "max-2xl-h": { raw: `not all and (min-height: ${xxl})` },
  "max-3xl-h": { raw: `not all and (min-height: ${xxxl})` },
  "max-4xl-h": { raw: `not all and (min-height: ${xxxxl})` },
  "max-5xl-h": { raw: `not all and (min-height: ${xxxxxl})` },
  mobile: { raw: "(hover: none) and (pointer: coarse)" },
  desktop: { raw: "(hover: hover) and (pointer: fine)" }
};
var tailwindTheme = { screens, extend: { screens: extendScreens } };

// src/joystickarea.ts
var { sin, cos, sqrt, pow, atan2 } = Math;
var pi = Math.PI;
var mountJoystickArea = ({
  joystick,
  mode = "follow",
  maxFollowDistance = 50,
  maxOriginDistance = 50,
  element,
  onStart,
  onEnd,
  onMove
}) => {
  if (!joystick) {
    console.error("JoystickArea: an joystick object is required");
  }
  let resetMovementTimeout = null;
  let endResetTimeout = null;
  const resetJoystick = () => {
    if (!joystick) {
      return;
    }
    joystick.identifier = null;
    joystick.isActive = false;
    joystick.origin.x = null;
    joystick.origin.y = null;
    joystick.origin.angle = null;
    joystick.origin.distance = null;
    joystick.origin.distanceRatio = null;
    joystick.follow.x = null;
    joystick.follow.y = null;
    joystick.follow.angle = null;
    joystick.follow.distance = null;
    joystick.follow.distanceRatio = null;
    joystick.current.x = null;
    joystick.current.y = null;
    joystick.movement.x = 0;
    joystick.movement.y = 0;
  };
  const handleTouchStart = (e) => {
    e.preventDefault();
    const touch = e.changedTouches.item(0);
    if (!touch || !joystick || joystick.identifier != void 0) {
      return;
    }
    const target = e.target;
    const rect = target.getBoundingClientRect();
    const currentX = touch.clientX - rect.left;
    const currentY = rect.height - (touch.clientY - rect.top);
    joystick.identifier = touch.identifier;
    joystick.isActive = true;
    joystick.origin.x = currentX;
    joystick.origin.y = currentY;
    joystick.origin.angle = 0;
    joystick.origin.distance = 0;
    joystick.origin.distanceRatio = 0;
    if (mode === "follow") {
      joystick.follow.x = currentX;
      joystick.follow.y = currentY;
      joystick.follow.angle = 0;
      joystick.follow.distance = 0;
      joystick.follow.distanceRatio = 0;
    }
    joystick.current.x = currentX;
    joystick.current.y = currentY;
    joystick.movement.x = 0;
    joystick.movement.y = 0;
    onStart?.(joystick);
  };
  const handleTouchMove = (e) => {
    e.preventDefault();
    if (!joystick) {
      return;
    }
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches.item(i);
      if (!touch || joystick.identifier !== touch.identifier) {
        continue;
      }
      if (joystick.origin.x === null || joystick.origin.y === null || joystick.current.x === null || joystick.current.y === null) {
        continue;
      }
      const target = e.target;
      const rect = target.getBoundingClientRect();
      const fingerPositionX = touch.clientX - rect.left;
      const fingerPositionY = rect.height - (touch.clientY - rect.top);
      const fingerOriginDistance = sqrt(
        pow(fingerPositionX - joystick.origin.x, 2) + pow(fingerPositionY - joystick.origin.y, 2)
      );
      joystick.origin.angle = (atan2(fingerPositionY - joystick.origin.y, fingerPositionX - joystick.origin.x) + 2 * pi) % (2 * pi);
      const currentX = mode === "origin" ? joystick.origin.x + Math.min(fingerOriginDistance, maxOriginDistance) * cos(joystick.origin.angle) : touch.clientX - rect.left;
      const currentY = mode === "origin" ? joystick.origin.y + Math.min(fingerOriginDistance, maxOriginDistance) * sin(joystick.origin.angle) : rect.height - (touch.clientY - rect.top);
      joystick.movement.x = currentX - joystick.current.x;
      joystick.movement.y = currentY - joystick.current.y;
      joystick.current.x = currentX;
      joystick.current.y = currentY;
      joystick.origin.distance = sqrt(
        pow(currentX - joystick.origin.x, 2) + pow(currentY - joystick.origin.y, 2)
      );
      if (mode === "origin") {
        if (joystick.origin.distance > maxOriginDistance - 0.01) {
          joystick.origin.distance = maxOriginDistance;
        }
      }
      joystick.origin.distanceRatio = maxOriginDistance ? joystick.origin.distance / maxOriginDistance : 1;
      if (joystick.origin.distanceRatio > 0.99) {
        joystick.origin.distanceRatio = 1;
      }
      if (mode === "follow") {
        if (joystick.follow.x !== null && joystick.follow.y !== null) {
          joystick.follow.angle = (atan2(fingerPositionY - joystick.follow.y, fingerPositionX - joystick.follow.x) + 2 * pi) % (2 * pi);
          joystick.follow.distance = sqrt(
            pow(currentX - joystick.follow.x, 2) + pow(currentY - joystick.follow.y, 2)
          );
          if (joystick.follow.distance > maxFollowDistance - 0.01) {
            joystick.follow.distance = maxFollowDistance;
          }
          joystick.follow.distanceRatio = maxFollowDistance ? joystick.follow.distance / maxFollowDistance : 1;
          joystick.follow.angle = (atan2(currentY - joystick.follow.y, currentX - joystick.follow.x) + 2 * pi) % (2 * pi);
          if (joystick.follow.distance >= maxFollowDistance) {
            const oppositeFollowAngle = Math.atan2(
              joystick.follow.y - currentY,
              joystick.follow.x - currentX
            );
            joystick.follow.x = currentX + maxFollowDistance * cos(oppositeFollowAngle);
            joystick.follow.y = currentY + maxFollowDistance * sin(oppositeFollowAngle);
          }
        }
      }
      joystick.origin.angle = (atan2(currentY - joystick.origin.y, currentX - joystick.origin.x) + 2 * pi) % (2 * pi);
      onMove?.(joystick);
      resetMovementTimeout && clearTimeout(resetMovementTimeout);
      resetMovementTimeout = setTimeout(() => {
        if (joystick && joystick.identifier !== void 0) {
          joystick.movement.x = 0;
          joystick.movement.y = 0;
          onMove?.(joystick);
        }
      }, 70);
    }
  };
  const handleTouchEnd = (e) => {
    e.preventDefault();
    if (!joystick) {
      return;
    }
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches.item(i);
      if (!touch || joystick.identifier !== touch.identifier) {
        continue;
      }
      joystick.movement.x = 0;
      joystick.movement.y = 0;
      onEnd?.(joystick);
      endResetTimeout = setTimeout(() => {
        resetJoystick();
        onEnd?.(joystick);
      }, 50);
    }
  };
  element.addEventListener(
    "touchstart",
    handleTouchStart
    /*, { passive: false } */
  );
  element.addEventListener(
    "touchmove",
    handleTouchMove
    /*, { passive: false } */
  );
  element.addEventListener(
    "touchend",
    handleTouchEnd
    /*, { passive: false } */
  );
  return () => {
    resetMovementTimeout && clearTimeout(resetMovementTimeout);
    endResetTimeout && clearTimeout(endResetTimeout);
    element.removeEventListener("touchstart", handleTouchStart);
    element.removeEventListener("touchmove", handleTouchMove);
    element.removeEventListener("touchend", handleTouchEnd);
  };
};

// src/listeners/devicetype.ts
var mountDeviceTypeListener = ({ onDeviceTypeChange }) => {
  const desktopQuery = window.matchMedia("(hover: hover) and (pointer: fine)");
  const mobileQuery = window.matchMedia("(hover: none) and (pointer: coarse)");
  const handler = () => {
    const isDesktop = desktopQuery.matches;
    const isMobile = mobileQuery.matches;
    browserStore.setState((s) => ({ ...s, isDesktop, isMobile }));
    onDeviceTypeChange?.({ isDesktop, isMobile });
  };
  handler();
  desktopQuery.addEventListener("change", handler);
  return () => desktopQuery.removeEventListener("change", handler);
};

// src/listeners/fullscreen.ts
var mountFullscreenListener = ({ onFullscreenChange }) => {
  const handler = () => {
    const isFullscreen = Boolean(document.fullscreenElement);
    browserStore.setState((s) => ({ ...s, isFullscreen }));
    onFullscreenChange?.({ isFullscreen });
  };
  handler();
  document.addEventListener("fullscreenchange", handler);
  return () => document.removeEventListener("fullscreenchange", handler);
};

// src/listeners/keyboard.ts
var mountKeyboardListener = ({ onKeyUp, onKeyDown }) => {
  const downHandler = (e) => {
    const { key, code } = e;
    const keyboard = getKeyboard();
    if (keyboard.codes[code] || keyboard.keys[key]) {
      return;
    }
    keyboardStore.setState((s) => ({
      ...s,
      codes: { ...s.codes, [code]: true },
      keys: { ...s.keys, [key]: true },
      ctrl: e.ctrlKey,
      shift: e.shiftKey,
      alt: e.altKey,
      meta: e.metaKey
    }));
    onKeyDown?.({
      code,
      key,
      ctrl: e.ctrlKey,
      shift: e.shiftKey,
      alt: e.altKey,
      meta: e.metaKey
    });
  };
  const upHandler = (e) => {
    keyboardStore.setState((s) => {
      const newKeyboard = { ...s, codes: { ...s.codes }, keys: { ...s.keys } };
      delete newKeyboard.codes[e.code];
      delete newKeyboard.keys[e.key];
      delete newKeyboard.keys[e.key.toUpperCase()];
      delete newKeyboard.keys[e.key.toLowerCase()];
      delete newKeyboard.keys.Dead;
      newKeyboard.ctrl = e.ctrlKey;
      newKeyboard.shift = e.shiftKey;
      newKeyboard.alt = e.altKey;
      newKeyboard.meta = e.metaKey;
      return newKeyboard;
    });
    onKeyUp?.({
      code: e.code,
      key: e.key,
      ctrl: e.ctrlKey,
      shift: e.shiftKey,
      alt: e.altKey,
      meta: e.metaKey
    });
  };
  window.addEventListener("keydown", downHandler);
  window.addEventListener("keyup", upHandler);
  return () => {
    window.removeEventListener("keydown", downHandler);
    window.removeEventListener("keyup", upHandler);
  };
};

// src/listeners/mousebuttons.ts
var mountMouseButtonsListener = ({
  onLeftMouseButtonDown,
  onMiddleMouseButtonDown,
  onRightMouseButtonDown,
  onLeftMouseButtonUp,
  onMiddleMouseButtonUp,
  onRightMouseButtonUp
}) => {
  const emptyObject = {};
  const downHandler = (e) => {
    const left = (e.buttons & 1) !== 0;
    const middle = (e.buttons & 4) !== 0;
    const right = (e.buttons & 2) !== 0;
    mouseStore.setState((s) => {
      const newMouse = structuredClone(s);
      const buttons = newMouse.buttons;
      buttons.left = left;
      buttons.middle = middle;
      buttons.right = right;
      return newMouse;
    });
    if (e.button === 0) {
      onLeftMouseButtonDown?.(emptyObject);
    } else if (e.button === 1) {
      onMiddleMouseButtonDown?.(emptyObject);
    } else if (e.button === 2) {
      onRightMouseButtonDown?.(emptyObject);
    }
  };
  const upHandler = (e) => {
    const left = (e.buttons & 1) !== 0;
    const middle = (e.buttons & 4) !== 0;
    const right = (e.buttons & 2) !== 0;
    mouseStore.setState((s) => {
      const newMouse = structuredClone(s);
      const buttons = newMouse.buttons;
      buttons.left = left;
      buttons.middle = middle;
      buttons.right = right;
      return newMouse;
    });
    if (e.button === 0) {
      onLeftMouseButtonUp?.(emptyObject);
    } else if (e.button === 1) {
      onMiddleMouseButtonUp?.(emptyObject);
    } else if (e.button === 2) {
      onRightMouseButtonUp?.(emptyObject);
    }
  };
  window.addEventListener("mousedown", downHandler);
  window.addEventListener("mouseup", upHandler);
  return () => {
    window.removeEventListener("mousedown", downHandler);
    window.removeEventListener("mouseup", upHandler);
  };
};

// src/listeners/mousemove.ts
var movementResetTimeout = null;
var mountMouseMoveListener = ({
  onMouseMove,
  mouseMovementResetDelay = 30
}) => {
  const payload = { position: { x: 0, y: 0 }, movement: { x: 0, y: 0 } };
  const handler = (e) => {
    const mouse = getMouse();
    const position = mouse.position;
    const movement = mouse.movement;
    position.x = e.clientX;
    position.y = window.innerHeight - e.clientY;
    movement.x = e.movementX;
    movement.y = -e.movementY;
    payload.position.x = position.x;
    payload.position.y = position.y;
    payload.movement.x = movement.x;
    payload.movement.y = movement.y;
    onMouseMove?.(payload);
    movementResetTimeout && clearTimeout(movementResetTimeout);
    if (mouseMovementResetDelay) {
      movementResetTimeout = setTimeout(() => {
        movement.x = 0;
        movement.y = 0;
        payload.movement.x = movement.x;
        payload.movement.y = movement.y;
        onMouseMove?.(payload);
      }, mouseMovementResetDelay);
    }
  };
  window.addEventListener("mousemove", handler);
  return () => {
    movementResetTimeout && clearTimeout(movementResetTimeout);
    window.removeEventListener("mousemove", handler);
  };
};

// src/listeners/mousescroll.ts
var resetTimeout = null;
var mountMouseScrollListener = ({
  onScroll,
  mouseScrollResetDelay = 100
}) => {
  const payload = { y: 0 };
  const handler = (e) => {
    const mouse = getMouse();
    const wheel = mouse.wheel;
    wheel.y = e.deltaY;
    payload.y = wheel.y;
    onScroll?.(payload);
    resetTimeout && clearTimeout(resetTimeout);
    if (mouseScrollResetDelay) {
      resetTimeout = setTimeout(() => {
        wheel.y = 0;
        payload.y = wheel.y;
        onScroll?.(payload);
      }, mouseScrollResetDelay);
    }
  };
  window.addEventListener("wheel", handler);
  return () => {
    resetTimeout && clearTimeout(resetTimeout);
    window.removeEventListener("wheel", handler);
  };
};

// src/listeners/pagefocus.ts
var mountPageFocusListener = ({ onPageFocusChange }) => {
  const handler = () => {
    const isPageFocused = document.hasFocus();
    browserStore.setState((s) => ({ ...s, isPageFocused }));
    onPageFocusChange?.({ isPageFocused });
  };
  handler();
  window.addEventListener("focus", handler);
  window.addEventListener("blur", handler);
  return () => {
    window.removeEventListener("focus", handler);
    window.removeEventListener("blur", handler);
  };
};

// src/listeners/pagevisibility.ts
var mountPageVisibilityListener = ({
  onPageVisibilityChange
}) => {
  const handler = () => {
    const isPageVisible = !document.hidden;
    browserStore.setState((s) => ({ ...s, isPageVisible }));
    onPageVisibilityChange?.({ isPageVisible });
  };
  handler();
  document.addEventListener("visibilitychange", handler);
  return () => document.removeEventListener("visibilitychange", handler);
};

// src/listeners/pointerlock.ts
var mountPointerLockListener = ({ onPointerLockChange }) => {
  const handler = () => {
    const locked = Boolean(document.pointerLockElement);
    mouseStore.setState((s) => {
      const newMouse = structuredClone(s);
      newMouse.locked = locked;
      return newMouse;
    });
    onPointerLockChange?.({ isPointerLocked: locked });
  };
  handler();
  document.addEventListener("pointerlockchange", handler);
  return () => document.removeEventListener("pointerlockchange", handler);
};

// src/listeners/resize.ts
var mountResizeListener = ({ onResize }) => {
  const payload = { width: 0, height: 0 };
  const handler = () => {
    const browser = getBrowser();
    const width = window.innerWidth;
    const height = window.innerHeight;
    browser.width = width;
    browser.height = height;
    payload.width = browser.width;
    payload.height = browser.height;
    onResize?.(payload);
  };
  handler();
  window.addEventListener("resize", handler);
  return () => window.removeEventListener("resize", handler);
};

// src/listeners/screenorientation.ts
var mountScreenOrientationListener = ({
  onScreenOrientationChange
}) => {
  const landscapeQuery = window.matchMedia("(orientation: landscape)");
  const portraitQuery = window.matchMedia("(orientation: portrait)");
  const handler = () => {
    const isLandscape = landscapeQuery.matches;
    const isPortrait = portraitQuery.matches;
    browserStore.setState((s) => ({ ...s, isLandscape, isPortrait }));
    onScreenOrientationChange?.({ isLandscape, isPortrait });
  };
  handler();
  landscapeQuery.addEventListener("change", handler);
  return () => landscapeQuery.removeEventListener("change", handler);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addMainLoopEffect,
  browserStore,
  createJoystick,
  enterFullscreen,
  exitFullscreen,
  getBrowser,
  getJoysticks,
  getKeyboard,
  getMouse,
  joysticksStore,
  keyboardStore,
  lockKeys,
  lockOrientation,
  lockPointer,
  mountDeviceTypeListener,
  mountFullscreenListener,
  mountJoystickArea,
  mountKeyboardListener,
  mountMouseButtonsListener,
  mountMouseMoveListener,
  mountMouseScrollListener,
  mountPageFocusListener,
  mountPageVisibilityListener,
  mountPointerLockListener,
  mountResizeListener,
  mountScreenOrientationListener,
  mouseStore,
  pauseMainLoop,
  resetJoysticks,
  resetKeyboard,
  resetMouse,
  resumeMainLoop,
  tailwindTheme,
  unlockKeys,
  unlockOrientation,
  unlockPointer
});
